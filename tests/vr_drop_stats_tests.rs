// Copyright 2020 Eishun Kondoh
// SPDX-License-Identifier: Apache-2.0

#[cfg(test)]
mod test_vr_drop_stats {
    use vr_type::vr_messages::sandesh::SandeshOp;
    use vr_type::vr_messages::vr_drop_stats::DropStats;

    #[test]
    fn complex_request() {
        let mut vds: DropStats = DropStats::default();

        vds.rid = 0;
        vds.core = 1;
        vds.discard = 2;
        vds.pcpu_stats_failure_status = 3;
        vds.pull = 4;
        vds.invalid_if = 5;
        vds.invalid_arp = 6;
        vds.trap_no_if = 7;
        vds.nowhere_to_go = 8;
        vds.flow_queue_limit_exceeded = 9;
        vds.flow_no_memory = 10;
        vds.flow_invalid_protocol = 11;
        vds.flow_nat_no_rflow = 12;
        vds.flow_action_drop = 13;
        vds.flow_action_invalid = 14;
        vds.flow_unusable = 15;
        vds.flow_table_full = 16;
        vds.interface_tx_discard = 17;
        vds.interface_drop = 18;
        vds.duplicated = 19;
        vds.push = 20;
        vds.ttl_exceeded = 21;
        vds.invalid_nh = 22;
        vds.invalid_label = 23;
        vds.invalid_protocol = 24;
        vds.interface_rx_discard = 25;
        vds.invalid_mcast_source = 26;
        vds.head_alloc_fail = 27;
        vds.pcow_fail = 28;
        vds.mcast_df_bit = 29;
        vds.mcast_clone_fail = 30;
        vds.no_memory = 31;
        vds.rewrite_fail = 32;
        vds.misc = 33;
        vds.invalid_packet = 34;
        vds.cksum_err = 35;
        vds.no_fmd = 36;
        vds.cloned_original = 37;
        vds.invalid_vnid = 38;
        vds.frag_err = 39;
        vds.invalid_source = 40;
        vds.l2_no_route = 41;
        vds.fragment_queue_fail = 42;
        vds.vlan_fwd_tx = 43;
        vds.vlan_fwd_enq = 44;
        vds.drop_new_flow = 45;
        vds.flow_evict = 46;
        vds.trap_original = 47;
        vds.leaf_to_leaf = 48;
        vds.bmac_isid_mismatch = 49;
        vds.pkt_loop = 50;
        vds.no_crypt_path = 51;
        vds.invalid_hbs_pkt = 52;

        let bytes = vds.write().unwrap();
        let vds: DropStats = DropStats::read(bytes).unwrap();

        assert_eq!(vds.rid, 0);
        assert_eq!(vds.core, 1);
        assert_eq!(vds.discard, 2);
        assert_eq!(vds.pcpu_stats_failure_status, 3);
        assert_eq!(vds.pull, 4);
        assert_eq!(vds.invalid_if, 5);
        assert_eq!(vds.invalid_arp, 6);
        assert_eq!(vds.trap_no_if, 7);
        assert_eq!(vds.nowhere_to_go, 8);
        assert_eq!(vds.flow_queue_limit_exceeded, 9);
        assert_eq!(vds.flow_no_memory, 10);
        assert_eq!(vds.flow_invalid_protocol, 11);
        assert_eq!(vds.flow_nat_no_rflow, 12);
        assert_eq!(vds.flow_action_drop, 13);
        assert_eq!(vds.flow_action_invalid, 14);
        assert_eq!(vds.flow_unusable, 15);
        assert_eq!(vds.flow_table_full, 16);
        assert_eq!(vds.interface_tx_discard, 17);
        assert_eq!(vds.interface_drop, 18);
        assert_eq!(vds.duplicated, 19);
        assert_eq!(vds.push, 20);
        assert_eq!(vds.ttl_exceeded, 21);
        assert_eq!(vds.invalid_nh, 22);
        assert_eq!(vds.invalid_label, 23);
        assert_eq!(vds.invalid_protocol, 24);
        assert_eq!(vds.interface_rx_discard, 25);
        assert_eq!(vds.invalid_mcast_source, 26);
        assert_eq!(vds.head_alloc_fail, 27);
        assert_eq!(vds.pcow_fail, 28);
        assert_eq!(vds.mcast_df_bit, 29);
        assert_eq!(vds.mcast_clone_fail, 30);
        assert_eq!(vds.no_memory, 31);
        assert_eq!(vds.rewrite_fail, 32);
        assert_eq!(vds.misc, 33);
        assert_eq!(vds.invalid_packet, 34);
        assert_eq!(vds.cksum_err, 35);
        assert_eq!(vds.no_fmd, 36);
        assert_eq!(vds.cloned_original, 37);
        assert_eq!(vds.invalid_vnid, 38);
        assert_eq!(vds.frag_err, 39);
        assert_eq!(vds.invalid_source, 40);
        assert_eq!(vds.l2_no_route, 41);
        assert_eq!(vds.fragment_queue_fail, 42);
        assert_eq!(vds.vlan_fwd_tx, 43);
        assert_eq!(vds.vlan_fwd_enq, 44);
        assert_eq!(vds.drop_new_flow, 45);
        assert_eq!(vds.flow_evict, 46);
        assert_eq!(vds.trap_original, 47);
        assert_eq!(vds.leaf_to_leaf, 48);
        assert_eq!(vds.bmac_isid_mismatch, 49);
        assert_eq!(vds.pkt_loop, 50);
        assert_eq!(vds.no_crypt_path, 51);
        assert_eq!(vds.invalid_hbs_pkt, 52);
    }

    #[test]
    fn empty_request() {
        let vds: DropStats = DropStats::default();
        let bytes = vds.write().unwrap();
        let vds: DropStats = DropStats::read(bytes).unwrap();
        assert_eq!(vds.op, SandeshOp::Add);
        assert_eq!(vds.rid, 0);
        assert_eq!(vds.core, 0);
        assert_eq!(vds.discard, 0);
        assert_eq!(vds.pcpu_stats_failure_status, 0);
        assert_eq!(vds.pull, 0);
        assert_eq!(vds.invalid_if, 0);
        assert_eq!(vds.invalid_arp, 0);
        assert_eq!(vds.trap_no_if, 0);
        assert_eq!(vds.nowhere_to_go, 0);
        assert_eq!(vds.flow_queue_limit_exceeded, 0);
        assert_eq!(vds.flow_no_memory, 0);
        assert_eq!(vds.flow_invalid_protocol, 0);
        assert_eq!(vds.flow_nat_no_rflow, 0);
        assert_eq!(vds.flow_action_drop, 0);
        assert_eq!(vds.flow_action_invalid, 0);
        assert_eq!(vds.flow_unusable, 0);
        assert_eq!(vds.flow_table_full, 0);
        assert_eq!(vds.interface_tx_discard, 0);
        assert_eq!(vds.interface_drop, 0);
        assert_eq!(vds.duplicated, 0);
        assert_eq!(vds.push, 0);
        assert_eq!(vds.ttl_exceeded, 0);
        assert_eq!(vds.invalid_nh, 0);
        assert_eq!(vds.invalid_label, 0);
        assert_eq!(vds.invalid_protocol, 0);
        assert_eq!(vds.interface_rx_discard, 0);
        assert_eq!(vds.invalid_mcast_source, 0);
        assert_eq!(vds.head_alloc_fail, 0);
        assert_eq!(vds.pcow_fail, 0);
        assert_eq!(vds.mcast_df_bit, 0);
        assert_eq!(vds.mcast_clone_fail, 0);
        assert_eq!(vds.no_memory, 0);
        assert_eq!(vds.rewrite_fail, 0);
        assert_eq!(vds.misc, 0);
        assert_eq!(vds.invalid_packet, 0);
        assert_eq!(vds.cksum_err, 0);
        assert_eq!(vds.no_fmd, 0);
        assert_eq!(vds.cloned_original, 0);
        assert_eq!(vds.invalid_vnid, 0);
        assert_eq!(vds.frag_err, 0);
        assert_eq!(vds.invalid_source, 0);
        assert_eq!(vds.l2_no_route, 0);
        assert_eq!(vds.fragment_queue_fail, 0);
        assert_eq!(vds.vlan_fwd_tx, 0);
        assert_eq!(vds.vlan_fwd_enq, 0);
        assert_eq!(vds.drop_new_flow, 0);
        assert_eq!(vds.flow_evict, 0);
        assert_eq!(vds.trap_original, 0);
        assert_eq!(vds.leaf_to_leaf, 0);
        assert_eq!(vds.bmac_isid_mismatch, 0);
        assert_eq!(vds.pkt_loop, 0);
        assert_eq!(vds.no_crypt_path, 0);
        assert_eq!(vds.invalid_hbs_pkt, 0);
    }
}
